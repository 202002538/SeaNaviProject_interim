# -*- coding: utf-8 -*-
"""자율운항선박 실시간 경로 추천시스템_프로젝트 페어

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YoV9Xj8rRQYn9Y_73omnmiXxiL9pWwkH
"""

!pip install basemap
!pip install basemap-data-hires

!pip install ipympl
!pip install nodejs-bin
!jupyter labextension install @jupyter-widgets/jupyterlab-manager
!jupyter labextension install jupyter-matplotlib
!pip install graphviz
!pip install shapely

import shapely.geometry
import pandas as pd
import numpy as np
import importlib
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from matplotlib.patches import Polygon
from datetime import datetime
import time
import copy

import math
import IPython

"""# 데이터 분류 및 그리드 나누기, AIS데이터 시각화"""

#대상 범위:(33, 125) ~ (35, 128.5)

base_lat = [33, 35]
base_lon = [125, 128.5]

#대상 범위 내 위도 1도와 경도 1도의 크기계산
'''
지구 평균 반지름 = 6371km
지구가 둥글기 때문에 위도가 커지면 경도의 1도 크기는 작아진다
위도 1도 = 6371 * 1도 * (파이/180)
경도 1도 = 6371 * 1도 * (파이/180) * cos(위도)
print해보면 위도 크기는 항상 일정, 경도 크기는 작아짐
'''

earth_radius = 6371
lat_distance_per_one = round(earth_radius * math.pi / 180, 3)
lon_distance_per_one = {0:111.322, 5:110.902, 10:109.643, 15:117.553, 20:114.650, 25:100.953, 30:96.490,
                        35:91.290, 40:85.397, 45:78.850, 50:71.700, 55:63.997, 60:55.803, 65:47.178, 70:38.188,
                        75:28.904, 80:19.394, 85:9.735, 90:0}

absolute_distance_pos = [[0],[0]]

for lat in range(base_lat[0]+1, base_lat[1]+1):
    absolute_distance_pos[0].append(lat_distance_per_one)
    absolute_distance_pos[1].append(lon_distance_per_one[(lat//5)*5])

print(absolute_distance_pos)

#대상 범위(33, 125) ~ (35, 128.5)를 47x40개 그리드로 쪼갠 좌표 얻음
grid_lat = [base_lat[0]]
grid_lon = [base_lon[0]]
gridmap_pivot_distance_km = 5 #그리드의 한 변이 5km가 되도록 나뉨

for ilat in range(1, len(absolute_distance_pos[0])):
    vlat = lat_distance_per_one # this is never changed. so not need
    while(True):
        tlat = 0
        if(tlat != gridmap_pivot_distance_km): tlat = gridmap_pivot_distance_km - tlat
        elif(vlat > gridmap_pivot_distance_km): tlat = gridmap_pivot_distance_km
        else: tlat = vlat # vlat <= gridmap_pivot_distance_km

        vlat -= tlat
        dlat = tlat/lat_distance_per_one

        grid_lat.append(grid_lat[-1] + dlat)

        if(vlat <= 0):
            break

collection_grid_lat = [(grid_lat[i]-base_lat[0])*(base_lat[1]-grid_lat[-1])/(grid_lat[-1]-base_lat[0]) for i in range(0, len(grid_lat))]
grid_lat = [x+y for x,y in zip(grid_lat, collection_grid_lat)]

for ilon in range(1, len(absolute_distance_pos[1])):
    vlon = absolute_distance_pos[1][ilon]
    while(True):
        tlon = 0
        if(tlon != gridmap_pivot_distance_km): tlon = gridmap_pivot_distance_km - tlon
        elif(vlon > gridmap_pivot_distance_km): tlon = gridmap_pivot_distance_km
        else: tlon = vlon # vlon <= gridmap_pivot_distance_km

        vlon -= tlon
        dlon = tlon/lon_distance_per_one[(ilon//5)*5]

        grid_lon.append(grid_lon[-1] + dlon)

        if(vlon <= 0):
            break

collection_grid_lon = [(grid_lon[i]-base_lon[0])*(base_lon[1]-grid_lon[-1])/(grid_lon[-1]-base_lon[0]) for i in range(0, len(grid_lon))]
grid_lon = [x+y for x,y in zip(grid_lon, collection_grid_lon)]

print('Grid_latitude len: %d'%(len(grid_lat)))
print('Grid_longitude len: %d'%(len(grid_lon)))
print(grid_lat)
print(grid_lon)

def draw_basemap_grid(lats, lons, m, color): #파라미터 color추가 (섬 영역 시각화 시 사용)
    x, y = m(lons, lats)
    xy = zip(x, y)
    poly = Polygon(list(xy), facecolor=color, edgecolor='black', lw=0.7, alpha=0.4)
    plt.gca().add_patch(poly)
    return poly

from google.colab import drive
drive.mount('/content/drive')

#연결된 구글 드라이브에 ais파일(.pkl)의 존재여부 확인
import os
import pickle

DATA_DIR = "/content/drive/MyDrive/"
DATA_NAME = 'Dynamic_20200204.csv'
skiprow_count = 3

f = open(DATA_DIR+DATA_NAME, 'r', encoding='cp949')
for i in range(0, skiprow_count):
    line = f.readline()
    if not line: break
    print(line)
f.close()

if os.path.isfile('/content/drive/MyDrive/ais_0204.pkl'): #피클 파일 존재
    print("ais 이미 존재")

    with open('/content/drive/MyDrive/ais_0204.pkl', 'rb') as f:
        ais = pickle.load(f)

    print('Data len in Range(After drop):' + str(len(ais)))

else:
    print("ais_dict 없음, 생성 및 저장 시작") #피클 파일 없
    chunk = pd.read_csv(DATA_DIR+DATA_NAME,
                      encoding='cp949', sep='\s+|,', engine='python',
                      skiprows=range(0, skiprow_count),
                      names=['MMSI','일자', '시간', '위도','경도', 'SOG', 'COG', 'Heading'], chunksize = 1000000)
    ais = pd.concat(chunk)

    with open('/content/drive/MyDrive/ais_0204.pkl', 'wb') as f:
        pickle.dump(ais, f)

    print('Data len in AIS:' + str(len(ais)))
    ais.drop(ais[(ais['위도'] < base_lat[0]) | (ais['위도'] > base_lat[1]) | (ais['경도'] < base_lon[0]) | (ais['경도'] > base_lon[1])].index, inplace=True)
    print('Data len in Range:' + str(len(ais)))

#시간 순으로 정렬

ais['시간'] = pd.to_datetime(ais['시간'])
ais['시간'] = ais['시간'].dt.time
ais.sort_values(by='시간', inplace = True)

ais

time_range = pd.date_range('00:00:00', '23:59:59', freq='30min').time

# AIS time slicing list (30min)
ais_ts_list = []

for i in range(len(time_range) - 1):
    start_time = time_range[i]
    end_time = time_range[i + 1]
    df = ais[(ais['시간'] >= start_time) & (ais['시간'] < end_time)]
    ais_ts_list.append(df)

# 마지막 시간 범위
start_time = time_range[-1]
df = ais[ais['시간'] >= start_time]
ais_ts_list.append(df)

ais_ts_list[47]

#연결된 구글 드라이브에 ais_dict파일(.pkl)의 존재여부 확인
#없으면 생성(30분 이상 소요) 및 저장, 있으면 읽어와 사용
import os
import pickle
mmsis = list(set(ais["MMSI"].tolist()))

if os.path.isfile('/content/drive/MyDrive/ais_dict_0204.pkl'):
    print("ais_dict 존재함")

else:
    print("ais_dict 없음, 생성 및 저장 시작")
    ais_dict = {}
    progress = []
    for i in range(0, len(mmsis)):
        per = int((i/len(mmsis))*100)
        if(per%5 == 0 and per not in progress):
            progress.append(per)
            print('Progress rate: %d/%d'%(per, 100))

        ais_dict[mmsis[i]] = ais[ais['MMSI'] == mmsis[i]]
    print('Progress rate: %d/%d'%(100, 100))

    # dictionary형태인 ais_dict를 pickle 파일로 저장
    with open('/content/drive/MyDrive/ais_dict_0204.pkl', 'wb') as f:
        pickle.dump(ais_dict, f)


#존재하는 pickle파일 read
with open('/content/drive/MyDrive/ais_dict_0204.pkl', 'rb') as f:
    ais_dict = pickle.load(f)

#20200204 AIS데이터 시각화

print('Draw Basemap')
f = plt.figure(figsize=[20,20])
m = Basemap(llcrnrlon = base_lon[0], llcrnrlat = base_lat[0],
            urcrnrlon = base_lon[1], urcrnrlat = base_lat[1],
            resolution='h', projection='merc',)
m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()

print('Draw Gridmap')
grid_map = {}
for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        p = draw_basemap_grid(lats, lons, m, "none")

        for i in range(len(time_range)): #(위도, 경도, 시간)을 key로 설정 -> 시간은 총 48개 구간
          key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], i)
          grid_map[key] = [p, [], '', 0, 0, 0, 0, 0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  # NESW, congestion, 영역, 해당영역 날씨 저장

print('Draw AIS data')
ais_lons = ais.경도.tolist()
ais_lats = ais.위도.tolist()

ais_lons, ais_lats = m(ais_lons, ais_lats)
plt.plot(ais_lons, ais_lats, 'o', c='royalblue', alpha=0.1, markersize=0.2)
plt.show()

grid_map.keys() #키값 형태 확인 (x, y, 0), (x, y, 1), ... (x, y, 47)

len(mmsis)

"""#방향 웨이트 계산"""

#좌표 v가 속하는 그리드의 키값 반환
def find_grid_key(llist, v):
    result = -1
    for i in range(0, len(llist)-1):
        if llist[i] <= v and llist[i+1] >= v:
            return llist[i]
    return result

#좌표 v가 속하는 그리드 list의 index 반환

def find_grid_idx(llist, v):
    result = -1
    for i in range(0, len(llist)-1):
        if llist[i] <= v and llist[i+1] >= v:
            return i
    return result

#시간 t가 속하는 시간대의 번호 반환
'''
ex) 00:31:12 -> 1 반환
    00:00:01 -> 0 반환

47번에 해당하는 23:30:00 이후 시간의 경우 for문에서 걸러지지 않음
ㄴ> 기본 반환값 result를 47로 놓음
'''

def find_time(llist, t):
  result = 47
  for i in range(0, len(llist)-1):
    if llist[i] <= t < llist[i+1]:
      return i
  return result

progress = []
for i, mmsi in enumerate(mmsis):
    per = int((i/len(mmsis))*100)
    if(per%5 == 0 and per not in progress):
        progress.append(per)
        print('Progress rate: %d/%d'%(per, 100))

    pais = ais_dict[mmsi]
    plat = copy.deepcopy(pais.위도.tolist())
    plon = copy.deepcopy(pais.경도.tolist())
    ptime = copy.deepcopy(pais.시간.tolist())

    klat = plat.pop(0)
    klon = plon.pop(0)
    ktime = ptime.pop(0) #해당 좌표에 배가 있었던 시간도 같이 고려
    key = '(%f,%f,%d)'%(find_grid_key(grid_lat, klat), find_grid_key(grid_lon, klon), find_time(time_range, ktime))

    while(len(plat) > 0):
        tklat = plat.pop(0)
        tklon = plon.pop(0)
        tktime = ptime.pop(0)
        tkey = '(%f,%f,%d)'%(find_grid_key(grid_lat, tklat), find_grid_key(grid_lon, tklon), find_time(time_range, tktime))

        if(key == tkey): #그리드 간 이동이 있을 때만 방향확인
            continue
        if (klat < tklat):
            grid_map[key][3] += 1
        if (klon < tklon):
            grid_map[key][4] += 1
        if (klat > tklat):
            grid_map[key][5] += 1
        if (klon > tklon):
            grid_map[key][6] += 1


        klat = tklat
        klon = tklon
        ktime = tktime
        key = '(%f,%f,%d)'%(find_grid_key(grid_lat, klat), find_grid_key(grid_lon, klon), find_time(time_range, ktime))
print('Progress rate: %d/%d'%(100, 100))

"""#혼잡도 계산"""

#시간대별 Congestion -> (grid 선박의 개수/전체 선박의 개수)

for time in range(len(time_range)):
  print("calculating... %d/%d"%(time+1, 48))
  mmsis_set = set(ais_ts_list[time]['MMSI'].tolist())
  n_of_ships = len(mmsis_set)

  for mmsi in mmsis_set:
    mmsi_info = ais_ts_list[time][ais_ts_list[time]['MMSI']==mmsi]
    mmsi_last = mmsi_info.iloc[-1]

    key = '(%f,%f,%d)'%(find_grid_key(grid_lat, mmsi_last['위도']), find_grid_key(grid_lon, mmsi_last['경도']), time)
    grid_map[key][7] += 1/n_of_ships

rkeys = grid_map.keys()
raw_data = {'key' : rkeys,
            'north_weight' : [grid_map[k][3] for k in rkeys],
            'east_weight' : [grid_map[k][4] for k in rkeys],
            'south_weight' : [grid_map[k][5] for k in rkeys],
            'west_weight' : [grid_map[k][6] for k in rkeys],
            'congestion' : [grid_map[k][7] for k in rkeys]
           }
weight_df = pd.DataFrame(raw_data)

weight_df

north, east, south, west, congestion  = 0, 0, 0, 0, 0
for i in range(0, 48):
  now = grid_map['(33.000000,125.000000,%d)'%i] #특정 좌표에서 시간대 구분없이 방향웨이트 총합 확인
  north += now[3]
  east += now[4]
  south += now[5]
  west += now[6]
  congestion += now[7]
print(north, east, south, west, congestion)

sum_congestion = 0

for congestion in weight_df['congestion']:
  sum_congestion += congestion

print(sum_congestion) #오차 -> 1/n 계산, 더하면서 소수점뒷자리가 길어져서 발생한듯 ??

"""#날씨 영역 지정"""

#섬의 영역을 정하는 코드

'''
대상지역의 주요 섬: 추자도, 거문도
- 추자도: (33.79361, 126.14111111)/ 제주시로 분류/ 크기:상추자도1.5㎢, 하추자도 3.5㎢
- 거문도: (34.00135, 127.50127222)/ 전남 여수시로 분류/ 크기: 12㎢

그리드의 키값과 날씨 관측지점의 좌표가 유클리디안 거리로 특정값 이하이면 섬 지정
이 거리제한을 어떤 값으로 정할 거냐 -> 좀 더 근거를 찾아보고 설명가능한 수치로 지정해야함
'''

chujado = [33.79361, 126.14111111]
geomundo = [34.00135, 127.50127222]
chujado_range, geomundo_range = 0.1, 0.1 #임시로 지정한 값

#그리드가 섬 부근에 속하는지 판단, 맞다면 해당 섬 이름 저장

chujado_lat_mean = (grid_lat[find_grid_idx(grid_lat, chujado[0])]+grid_lat[find_grid_idx(grid_lat, chujado[0])+1])/2
chujado_lon_mean = (grid_lon[find_grid_idx(grid_lon, chujado[1])]+grid_lon[find_grid_idx(grid_lon, chujado[1])+1])/2
geomundo_lat_mean = (grid_lat[find_grid_idx(grid_lat, geomundo[0])]+grid_lat[find_grid_idx(grid_lat, geomundo[0])+1])/2
geomundo_lon_mean = (grid_lon[find_grid_idx(grid_lon, geomundo[1])]+grid_lon[find_grid_idx(grid_lon, geomundo[1])+1])/2

for ilon in range(len(grid_lon)-1):
    for ilat in range(len(grid_lat)-1):
      if math.sqrt(((grid_lat[ilat]+grid_lat[ilat+1])/2-chujado_lat_mean)**2 + ((grid_lon[ilon]+grid_lon[ilon+1])/2-chujado_lon_mean)**2) <= chujado_range:  #추자도 부근인지
          print("chu", grid_lon[ilon], grid_lat[ilat])
          for i in range(len(time_range)):
            key = '(%f,%f,%d)'%(grid_lat[ilat], grid_lon[ilon], i)
            grid_map[key][8] = "chu"
      if math.sqrt(((grid_lat[ilat]+grid_lat[ilat+1])/2-geomundo_lat_mean)**2 + ((grid_lon[ilon]+grid_lon[ilon+1])/2-geomundo_lon_mean)**2) <= geomundo_range:  #거문도 부근인지
          print("geo",  grid_lon[ilon], grid_lat[ilat])
          for i in range(len(time_range)):
            key = '(%f,%f,%d)'%(grid_lat[ilat], grid_lon[ilon], i)
            grid_map[key][8] = "geo"

rkeys = grid_map.keys()
raw_data = {'key' : rkeys,
            'north_weight' : [grid_map[k][3] for k in rkeys],
            'east_weight' : [grid_map[k][4] for k in rkeys],
            'south_weight' : [grid_map[k][5] for k in rkeys],
            'west_weight' : [grid_map[k][6] for k in rkeys],
            'congestion' : [grid_map[k][7] for k in rkeys],
            'area': [grid_map[k][8] for k in rkeys]
           }
grid_data_df = pd.DataFrame(raw_data)

grid_data_df

#섬 부근 영역 설정 시각화
#추자도 부근 노란색, 거문도 부근 파란색

print('Draw Basemap')
f = plt.figure(figsize=[20,20])
m = Basemap(llcrnrlon = base_lon[0], llcrnrlat = base_lat[0],
            urcrnrlon = base_lon[1], urcrnrlat = base_lat[1],
            resolution='h', projection='merc',)
m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()

print('Draw Gridmap')
for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)

        if grid_map[key][8] == "chu":
          p = draw_basemap_grid(lats, lons, m, "yellow")
        elif grid_map[key][8] == "geo":
          p = draw_basemap_grid(lats, lons, m, "blue")
        else:
          p = draw_basemap_grid(lats, lons, m, "none")

ChuDATA_NAME = '200203~200331_추자도.csv'
skiprow_weather_count = 1

f = open(DATA_DIR+ChuDATA_NAME, 'r', encoding='cp949')
for i in range(0, skiprow_weather_count):
    line = f.readline()
    if not line: break
    print(line)
f.close()

chu_weather = pd.read_csv(DATA_DIR+ChuDATA_NAME,
                          encoding='cp949', sep='\s+|,', engine='python', skiprows=range(0, skiprow_weather_count),
                          names=['지점', '일자', '시간', '풍속(m/s)', '풍향(deg)', 'GUST풍속(m/s)', '현지기압(hPa)', '습도(%)', '기온(°C)', '수온(°C)', '최대파고(m)', '유의파고(m)', '평균파고(m)', '파주기(sec)', '파향(deg)'])

print('Data len in Chu:' + str(len(chu_weather)))

#날씨데이터 중 빈칸이 존재하는 행 제거
chu_weather = chu_weather.dropna()
print('Data len in Chu NN: ' + str(len(chu_weather)))

#ais['일자']와 일치하는 데이터만 추출
chu_weather = chu_weather[chu_weather['일자'].isin(ais['일자'])]
print('Data len in Chu 200204 : ' + str(len(chu_weather)))

GeoDATA_NAME = '200203~200331_거문도.csv'

f = open(DATA_DIR+GeoDATA_NAME, 'r', encoding='cp949')
for i in range(0, skiprow_weather_count):
    line = f.readline()
    if not line: break
    print(line)
f.close()

geo_weather = pd.read_csv(DATA_DIR+GeoDATA_NAME,
                          encoding='cp949', sep='\s+|,', engine='python', skiprows=range(0, skiprow_weather_count),
                          names=['지점', '일자', '시간', '풍속(m/s)', '풍향(deg)', 'GUST풍속(m/s)', '현지기압(hPa)', '습도(%)', '기온(°C)', '수온(°C)', '최대파고(m)', '유의파고(m)', '평균파고(m)', '파주기(sec)', '파향(deg)'])

print('Data len in Geo:' + str(len(geo_weather)))

#날씨데이터 중 빈칸이 존재하는 행 제거
geo_weather = geo_weather.dropna()
print('Data len in Geo NN: ' + str(len(geo_weather)))

#ais['일자']와 일치하는 데이터만 추출
geo_weather = geo_weather[geo_weather['일자'].isin(ais['일자'])]
print('Data len in Geo 200204 : ' + str(len(geo_weather)))

print(chu_weather) #추자도 200204 날씨데이터 확인

print(geo_weather) #거문도 200204 날씨데이터 확인

print(chu_weather['시간']) # 추자도 날씨데이터의 시간 형식 확인

print(geo_weather['시간']) # 거문도 날씨데이터의 시간 형식 확인

#날씨데이터 time slicing
def ts_weather(weather_df, time_format):

  weather_ts_list = []

  for i in range(len(time_range) - 1):
        start_time = time_range[i].strftime(time_format)
        end_time = time_range[i + 1].strftime(time_format)
        df = weather_df[(weather_df['시간'] >= start_time) & (weather_df['시간'] < end_time)]
        weather_ts_list.append(df)

  # 마지막 시간 범위
  start_time = time_range[-1].strftime(time_format)
  df = weather_df[weather_df['시간'] >= start_time]
  weather_ts_list.append(df)

  return weather_ts_list

chu_weather_ts = ts_weather(chu_weather, '%H:%M')
geo_weather_ts = ts_weather(geo_weather, '%H:%M')

chu_weather_ts[26] #추자도 200204 13:00 날씨 데이터 확인

geo_weather_ts[2] #거문도 200204 01:00 날씨 데이터 확인

def insert_weather_to_grid(grid_map, weather_ts, area_label, time_range):
  for time_idx in range(len(time_range)):
    weather_data = weather_ts[time_idx]
    for _, row in weather_data.iterrows():
      for key in grid_map.keys():
        lat, lon, t_idx = eval(key)
        if t_idx == time_idx and grid_map[key][8] == area_label:
          grid_map[key][9] = row['풍속(m/s)']
          grid_map[key][10] = row['풍향(deg)']
          grid_map[key][11] = row['GUST풍속(m/s)']
          grid_map[key][12] = row['현지기압(hPa)']
          grid_map[key][13] = row['습도(%)']
          grid_map[key][14] = row['기온(°C)']
          grid_map[key][15] = row['수온(°C)']
          grid_map[key][16] = row['최대파고(m)']
          grid_map[key][17] = row['유의파고(m)']
          grid_map[key][18] = row['평균파고(m)']
          grid_map[key][19] = row['파주기(sec)']
          grid_map[key][20] = row['파향(deg)']

insert_weather_to_grid(grid_map, chu_weather_ts, "chu", time_range)
insert_weather_to_grid(grid_map, geo_weather_ts, "geo", time_range)

rkeys = grid_map.keys()
raw_data = {
    'key': rkeys,
    'north_weight': [grid_map[k][3] for k in rkeys],
    'east_weight': [grid_map[k][4] for k in rkeys],
    'south_weight': [grid_map[k][5] for k in rkeys],
    'west_weight': [grid_map[k][6] for k in rkeys],
    'congestion': [grid_map[k][7] for k in rkeys],
    'area': [grid_map[k][8] for k in rkeys]
}
weather_columns = [
    'wind speed(m/s)', 'wind direction(deg)', 'GUST wind speed(m/s)', 'atmospheric pressure(hPa)',
    'humidity(%)', 'temperature(°C)', 'water temperature(°C)', 'max wave height(m)',
    'sign wave height(m)', 'avg wave height(m)', 'wave period(sec)', 'wave direction(deg)'
]

# 각 날씨 데이터 컬럼을 추가
for i, col in enumerate(weather_columns, start=9):
    raw_data[col] = [grid_map[k][i] for k in rkeys]

grid_data_df = pd.DataFrame(raw_data)

grid_data_df

'''
그리드 별로 방향웨이트, 혼잡도, 지역정보(날씨정보)가
저장된 csv파일 저장됨
데이터 전처리 완료
'''
grid_data_df.to_csv('grid_data_df.csv')

"""#MMSI 선정
출발지와 목적지가 명확한 mmsi 선박 찾기

*기반으로 웨이포인트 설정
"""

mmsi_index = mmsis.index('rsK/TL2snFF0wlYXzPTWUQ==') #시각화 하려고 하는 mmsi(20번째)

pais = ais_dict[mmsis[mmsi_index]]
ais_lats = copy.deepcopy(pais.위도.tolist())
ais_lons = copy.deepcopy(pais.경도.tolist())

f = plt.figure(figsize=[20,20])
m = Basemap(llcrnrlon = base_lon[0], llcrnrlat = base_lat[0],
        urcrnrlon = base_lon[1], urcrnrlat = base_lat[1],
        resolution='h', projection='merc',)

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')
m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

'''
20번째 mmsi는 시작그리드와 종료그리드 같음 -> 목포<->제주를 왕복함
절반 나눠서 시각화 또는 웨이포인트를 찍어보면 명확
결론: pais[:(len(pais)//2)]만 사용하자. 목포 -> 제주
'''
pais = ais_dict[mmsis[mmsi_index]]
pais1 = pais[:(len(pais)//2)]
pais2 = pais[(len(pais)//2):]

ais_lats1 = copy.deepcopy(pais1.위도.tolist())
ais_lons1 = copy.deepcopy(pais1.경도.tolist())
ais_lats2 = copy.deepcopy(pais2.위도.tolist())
ais_lons2 = copy.deepcopy(pais2.경도.tolist())

f = plt.figure(figsize=[20,20])
m = Basemap(llcrnrlon = base_lon[0], llcrnrlat = base_lat[0],
        urcrnrlon = base_lon[1], urcrnrlat = base_lat[1],
        resolution='h', projection='merc',)

x1, y1 = m(ais_lons1, ais_lats1)
x2, y2 = m(ais_lons2, ais_lats2)
m.plot(x1, y1, linewidth=3, color='g')
m.plot(x2, y2, linewidth=3, color='b')
m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

"""#waypoint 나누기"""

pais = pais[:(len(pais)//2)] #절반만 사용

print(len(pais))

#Waypoint 총 7개 선정(임의값임)
#경로가 꺾여야 할 지점마다 웨이포인트 지정함
ais_lats = copy.deepcopy(pais.위도.tolist())
ais_lons = copy.deepcopy(pais.경도.tolist())

waypoint_index = [0, 1000, 1300, 1680, 2100, 3000, -1]
waypoint = []

for i in waypoint_index:
  waypoint.append((ais_lats[i], ais_lons[i]))

for i in range(len(waypoint)):
  print(waypoint[i])

#웨이포인트 시각화
f = plt.figure(figsize=[20,20])
m = Basemap(llcrnrlon = base_lon[0], llcrnrlat = base_lat[0],
        urcrnrlon = base_lon[1], urcrnrlat = base_lat[1],
        resolution='h', projection='merc',)

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g') #기존 경로

way_x, way_y = zip(*waypoint)
a, b = m(way_y, way_x)
for i in range(len(way_x)):
   m.scatter(a, b, 10, marker = 'o', color='r') #웨이포인트

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

#웨이포인트를 그리드와 맵핑
grid_lat_20 = []
grid_lon_20 = []

for idx in range(len(waypoint)):
    grid_lat_20.append(find_grid_key(grid_lat, waypoint[idx][0]))
    grid_lon_20.append(find_grid_key(grid_lon, waypoint[idx][1]))

for i in range(len(grid_lat_20)):
  print(grid_lat_20[i], grid_lon_20[i])

#웨이포인트 그리드 시각화
f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        p = draw_basemap_grid(lats, lons, m, "none")

for ilon, ilat in zip(grid_lon_20, grid_lat_20):
    lats = [ilat, ilat + (grid_lat[1] - grid_lat[0]), ilat + (grid_lat[1] - grid_lat[0]), ilat]
    lons = [ilon, ilon, ilon + (grid_lon[1] - grid_lon[0]), ilon + (grid_lon[1] - grid_lon[0])]
    draw_basemap_grid(lats, lons, m, 'red')

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

"""# 혼잡도 Score 함수
quantile 지정 및 그에 따른 스코어 산출
"""

score_dic = {}
for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        for i in range(len(time_range)):
          key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], i)
          score_dic[key] = [0, 0, 0, 0, 0] #"트래픽 볼륨", 날씨점수, 혼잡도점수, 트래픽점수, 총점수 저장

#Q1, Q2, Q3 value 값을 얻는 함수
def quantile_congestion(score_dic, time_idx, index):
    value_list = []
    for key in score_dic.keys():
        lat, lon, t_idx = eval(key)
        if t_idx == time_idx:
            value_list.append(score_dic[key][index])

    non_zero_values = [value for value in value_list if value != 0]

    value_array = np.array(non_zero_values)

    Q1 = np.percentile(value_array, 50)
    Q2 = np.percentile(value_array, 80)
    return [Q1, Q2]

# score를 계산하는 함수
def score_congestion(dic, index):
    for time_idx in range(48):
        Q = quantile_congestion(dic, time_idx, index)
        for key in dic.keys():
            lat, lon, t_idx = eval(key)
            if t_idx == time_idx:
                value = dic[key][index]
                if value == 0:
                    score_value = 1
                elif 0 < value <= Q[0]:
                    score_value = 2
                elif Q[0] < value <= Q[1]:
                    score_value = 3
                else:
                    score_value = 4
                score_dic[key][2] = score_value
    return dic

"""#트래픽 볼륨 Score 함수
출발-도착지 위치비교로 방향웨이트 정의

quantile 지정 및 그에 따른 스코어 산출
"""

# time index 0을 기준으로 구함

def direction_weight(dic, way_lat, way_lon): # 출발지점과 도착지점 input으로 넣음 -> [위도, 경도] 리스트로 넣음

    for idx in range(len(way_lat)-1):
        if (way_lat[idx] > way_lat[idx + 1]) and (way_lon[idx] > way_lon[idx + 1]): # 남서쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x2_index, x1_index+1):
                for j in range(y2_index, y1_index+1):
                    key = '(%f,%f,%d)'%(grid_lat[i], grid_lon[j], 0)
                    if (grid_lat[i] == grid_lat[x2_index]):
                       score_dic[key][0] = dic[key][6]

                    elif (grid_lon[j] == grid_lon[y2_index]):
                        score_dic[key][0] = dic[key][5]

                    else:
                        score_dic[key][0] = dic[key][5] + dic[key][6]

        elif (way_lat[idx] > way_lat[idx + 1]) and (way_lon[idx] < way_lon[idx + 1]): # 남동쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x2_index, x1_index+1):
                for j in range(y1_index, y2_index+1):
                    key = '(%f,%f,%d)'%(grid_lat[i], grid_lon[j], 0)
                    if (grid_lat[i] == grid_lat[x2_index]):
                        score_dic[key][0] = dic[key][4]

                    elif (grid_lon[j] == grid_lon[y1_index]):
                        score_dic[key][0] = dic[key][5]

                    else:
                        score_dic[key][0] = dic[key][4] + dic[key][5]

        elif (way_lat[idx] < way_lat[idx + 1]) and (way_lon[idx] < way_lon[idx + 1]): # 북동쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x1_index, x2_index+1):
                for j in range(y1_index, y2_index+1):
                    key = '(%f,%f,%d)'%(grid_lat[i], grid_lon[j], 0)
                    if (grid_lat[i] == grid_lat[x2_index]):
                        score_dic[key][0] = dic[key][4]

                    elif (grid_lon[j] == grid_lon[y2_index]):
                        score_dic[key][0] = dic[key][3]

                    else:
                        score_dic[key][0] = dic[key][3] + dic[key][4]

        elif (way_lat[idx] < way_lat[idx + 1]) and (way_lon[idx] > way_lon[idx + 1]): # 북서쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x1_index, x2_index+1):
                for j in range(y2_index, y1_index+1):
                    key = '(%f,%f,%d)'%(grid_lat[i], grid_lon[j], 0)
                    if (grid_lat[i] == grid_lat[x2_index]):
                        score_dic[key][0] = dic[key][6]

                    elif (grid_lon[j] == grid_lon[y2_index]):
                        score_dic[key][0] = dic[key][4]

                    else:
                        score_dic[key][0] = dic[key][4] + dic[key][6]

        elif (way_lat[idx] > way_lat[idx + 1]) and (way_lon[idx] == way_lon[idx + 1]): # 남쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x2_index, x1_index+1):
                key = '(%f,%f,%d)'%(grid_lat[i], way_lon[idx], 0)
                score_dic[key][0] = dic[key][5]

        elif (way_lat[idx] < way_lat[idx + 1]) and (way_lon[idx] == way_lon[idx + 1]): # 북쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(x1_index, x2_index+1):
                key = '(%f,%f,%d)'%(grid_lat[i], way_lon[idx], 0)
                score_dic[key][0] = dic[key][3]

        elif (way_lat[idx] == way_lat[idx + 1]) and (way_lon[idx] < way_lon[idx + 1]): # 동쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(y1_index, y2_index+1):
                key = '(%f,%f,%d)'%(way_lat[idx], grid_lon[i], 0)
                score_dic[key][0] = dic[key][4]

        elif (way_lat[idx] == way_lat[idx + 1]) and (way_lon[idx] > way_lon[idx + 1]): # 서쪽
            x1_index = find_grid_idx(grid_lat, way_lat[idx])
            y1_index = find_grid_idx(grid_lon, way_lon[idx])
            x2_index = find_grid_idx(grid_lat, way_lat[idx + 1])
            y2_index = find_grid_idx(grid_lon, way_lon[idx + 1])
            for i in range(y2_index, y1_index+1):
                key = '(%f,%f,%d)'%(way_lat[idx], grid_lon[i], 0)
                score_dic[key][0] = dic[key][6]

        else: # 출발지와 waypoint가 겹치는 경우
            print("출발, 도착 지점 명확하게 설정")

for key in score_dic.keys():
    lat, lon, t_idx = eval(key)
    if (t_idx == 0):
        print(key + "'s traffic volume: " + str(score_dic[key][0]))

def quantile_traffic_volume(dic, time_idx):
    value_list = []
    for key in dic.keys():
        lat, lon, t_idx = eval(key)
        if t_idx == 0:
            value_list.append(dic[key][0])
    non_zero_values = [value for value in value_list if value != 0]

    value_array = np.array(non_zero_values)

    quantile_values = np.quantile(value_array, [0.3, 0.6])
    return quantile_values

def score_traffic_volume(dic):
    Q = quantile_traffic_volume(dic, 0)
    for key in dic.keys():
        lat, lon, t_idx = eval(key)
        if t_idx == 0:
            value = dic[key][0]
            if value == 0:
                score_value = 4
            elif 0 < value <= Q[0]:
                score_value = 3
            elif Q[0] < value <= Q[1]:
                score_value = 2
            else:
                score_value = 1
            score_dic[key][3] = score_value
    return dic

"""#그리드 별 스코어 계산"""

def score(score_dic, alpha): # score(score_dic, 안전에 대한 가중치)
    for key in score_dic.keys():
        lat, lon, t_idx = eval(key)
        if t_idx == 0:
            score_dic[key][4] = alpha * score_dic[key][2] + (1 - alpha) * score_dic[key][3]

#혼잡도 스코어 계산
quantile_congestion(grid_map, 0, 7)
score_congestion(grid_map, 7)

#트래픽 스코어 계산
direction_weight(grid_map, grid_lat_20, grid_lon_20)
quantile_traffic_volume(score_dic, 0)
score_traffic_volume(score_dic)

#최종 스코어 계산
score(score_dic, 0.5)

rkeys = grid_map.keys()
raw_data = {
    'key': rkeys,
    'traffic_volume': [score_dic[k][0] for k in rkeys],
    'weather_score': [score_dic[k][1] for k in rkeys],
    'congestion_score': [score_dic[k][2] for k in rkeys],
    'traffic_score': [score_dic[k][3] for k in rkeys],
    'total_score': [score_dic[k][4] for k in rkeys],
}
score_df = pd.DataFrame(raw_data)
score_df.to_csv('score_df.csv') #csv파일로 저장

score_df

with open('/content/drive/MyDrive/score_0204.pkl', 'wb') as f: #pickle파일로 저장
    pickle.dump(score_df, f)

def draw_basemap_grid2(lats, lons, m, color, alpha): #파라미터 alpha 추가 (최종 스코어 시각화용)
    x, y = m(lons, lats)
    xy = zip(x, y)
    poly = Polygon(list(xy), facecolor=color, edgecolor='black', lw=0.7, alpha=alpha)
    plt.gca().add_patch(poly)
    return poly

#시각화 1: 안전(혼잡도)과 효율(트래픽)이 5:5
#색이 진할수록 스코어가 높음 -> 불리한 그리드
score(score_dic, 0.5)

f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)
        p = draw_basemap_grid2(lats, lons, m, "r", score_dic[key][4]/10)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

#시각화 2: 안전(혼잡도)과 효율(트래픽)이 9:1
score(score_dic, 0.9)

f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)
        p = draw_basemap_grid2(lats, lons, m, "r", score_dic[key][4]/10)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

#시각화 3: 안전(혼잡도)과 효율(트래픽)이 1:9
score(score_dic, 0.1)

f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)
        p = draw_basemap_grid2(lats, lons, m, "r", score_dic[key][4]/10)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

#시각화 4: 안전(혼잡도)과 효율(트래픽)이 0:10
score(score_dic, 0.0)

f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)
        p = draw_basemap_grid2(lats, lons, m, "r", score_dic[key][4]/10)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()

#시각화 5: 안전(혼잡도)과 효율(트래픽)이 10:0
score(score_dic, 1.0)

f = plt.figure(figsize=[20, 20])
m = Basemap(llcrnrlon=base_lon[0], llcrnrlat=base_lat[0],
            urcrnrlon=base_lon[1], urcrnrlat=base_lat[1],
            resolution='h', projection='merc')

x, y = m(ais_lons, ais_lats)
m.plot(x, y, linewidth=3, color='g')

for ilon in range(1, len(grid_lon)):
    for ilat in range(1, len(grid_lat)):
        lats = [grid_lat[ilat-1], grid_lat[ilat], grid_lat[ilat], grid_lat[ilat-1]]
        lons = [grid_lon[ilon-1], grid_lon[ilon-1], grid_lon[ilon], grid_lon[ilon]]
        key = '(%f,%f,%d)'%(grid_lat[ilat-1], grid_lon[ilon-1], 0)
        p = draw_basemap_grid2(lats, lons, m, "r", score_dic[key][4]/10)

m.drawcoastlines()
m.drawcountries()
m.drawmapboundary()
m.shadedrelief()
plt.show()